from constants import *

import random
import tkinter as tk


class Player:
    def __init__(self, color):
        self.color = color

        if(self.color == 'white'):
            self.worker1 = Worker('A')
            self.worker2 = Worker('B')

        elif(self.color == 'blue'):
            self.worker1 = Worker('Y')
            self.worker2 = Worker('Z')

        else:
            print("ERROR: Invalid player name")

    def choose_move(self, legal_moves):
        pass

    def choose_build(self, legal_builds):
        pass
    
    def choose_worker(self):
        pass

    
class PlayerFactory():
    def create_player(self, kind, color):
        if (kind == "human"):
            return HumanPlayer(color)
        if (kind == "random"):
            return RandomPlayer(color)
        if (kind == "heuristic"):
            return HeuristicPlayer(color)
        
        
class HumanPlayer(Player):
    def __init__(self, color):
        super().__init__(color)

    #returns chosen worker of curr player
    def choose_worker(self):
        while True:
            worker_name = input("Select a worker to move\n")
            if(worker_name == self.worker1.name): 
                worker = self.worker1
                return worker
            elif(worker_name == self.worker2.name):
                worker = self.worker2
                return worker
            elif(worker_name != ['A', 'B', 'Y', 'Z']):
                print("Not a valid worker")
            elif(worker_name not in [self.worker1.name or self.worker2.name]):
                print("That is not your worker")
    
    #legal_moves generated by calling get_legal_moves() in Board
    def choose_move(self, legal_moves, worker):
        while True:
            move_dir = input("Select a direction to move {}\n".format(directions.keys()))
            if(not move_dir in directions.keys()):
                print("Not a valid direction")
            else:
                move = Move(move_dir, worker)
                valid_move = False
                for item in legal_moves:
                    if (item == move):
                        valid_move = True
                if not valid_move:
                    print("Cannot move {}".format(move_dir))
                else:
                    return move

    #legal_builds generated by calling get_legal_builds() in Board
    def choose_build(self, legal_builds, worker):
        while True:
            build_dir = input("Select a direction to build {}\n".format(directions.keys()))
            if(build_dir not in directions.keys()):
                print("Not a valid direction")
            else:
                build = Build(build_dir, worker)
                valid_build = False
                print(len(legal_builds))
                for item in legal_builds:
                    if item == build:
                        valid_build = True
                if not valid_build:
                    print("Cannot build {}".format(build_dir))
                else:
                    return build

class RandomPlayer(Player):
    def __init__(self, color):
        super().__init__(color)

    #legal_moves generated by calling get_legal_moves() in PlayGame
    def choose_move(self, legal_moves):
        move = random.choice(legal_moves)
        return move

    #legal_builds generated by calling get_legal_builds() in PlayGame
    def choose_build(self, legal_builds):
        build = random.choice(legal_builds)
        return build




class HeuristicPlayer(Player):
    def __init__(self, color):
        super().__init__(color)

    def choose_move(self, legal_moves):
        pass 

    def choose_build(self, legal_builds):
        pass
    



class Worker:
    def __init__(self, name, row=4, col=3):
        self.name = name
        self.row = row
        self.col = col
        
        #initialize worker to default location depending on name
        if(self.name == 'A'):
            self.update_location(3,1)
        
        elif(self.name == 'B'):
            self.update_location(1,3)

        elif(self.name == 'Y'):
            self.update_location(1, 1)

        elif(self.name == 'Z'):
            self.update_location(3, 3)

        else:
            print("ERROR: Invalid worker name")

    # def find_legal_moves(self):
    #     return self.board.find_legal_moves(self)

    # def find_legal_builds(self):
    #     return self.board.find_legal_builds(self)

    def update_location(self, new_row, new_col):
        self.row = new_row
        self.col = new_col


    def get_move(self, new_square):
        drow = new_square.row - self.row
        dcol = new_square.col - self.col
        dcoords = (drow, dcol)
        
        if(dcoords in inv_directions):
            move = Move(inv_directions[dcoords], self)
            return move

        return None

    
    def get_build(self, new_square):
        drow = new_square.row - self.row
        dcol = new_square.col - self.col
        dcoords = (drow, dcol)
        
        if(dcoords in inv_directions):
            build = Build(inv_directions[dcoords], self)
            return build

        return None



class Square:
    def __init__(self, row, col, board):
        self.row = row
        self.col = col
        self.occupant = None
        self.level = 0

        self.board = board
        self.display_str = tk.StringVar()
        #self.display_str.set("hi")
        self.button = tk.Button(self.board.board_frame, textvariable=self.display_str, command=self.clicked, width = 7, height = 3)
        self.button.config(bg = "white")
        self.update_display_str()

    def update_display_str(self):
        if self.occupant is None:
            self.display_str.set("{} ".format(self.level))
            #print(self.display_str.get())
        else:
            self.display_str.set("{}{}".format(self.level, self.occupant.name))
            #print('beep')


    def update_occupant(self, new_occupant = None):
        #if move into square, update occupant. if more out of square, occupant = None.
        if new_occupant is None:
            self.occupant = None
        else:
            self.occupant = new_occupant
        self.update_display_str()

    def update_level(self):
        #if level < 4, build up 1 level.
        if self.level < 4:
            self.level += 1
        # else:
        #     print("Cannot build {}".format(self.direction))

        self.update_display_str() 

    def __str__(self):
        if (self.occupant == None):
            return '|{} '.format(self.level)
        else:
            return '|{}{}'.format(self.level, self.occupant.name)


    def clicked(self):
        #pass
        state = self.board.playgame.game_state
        player = self.board.curr_player
        #playgame = self.board.playgame
        #board = self.play_game.board

        if(state == "choose_worker"):
            #print("boop, {} {}".format(self.row, self.col))
            valid_squares = self.board.get_worker_moves(self.occupant)
            if (self.occupant == player.worker1 or self.occupant == player.worker2) and len(valid_squares) > 0:
                self.board.playgame.game_state = "choose_move"
                self.button.config(fg = "green")
                #print("hello")
                self.board.playgame.selected_worker = self.occupant

                for square in valid_squares:
                    square.button.config(bg = "green")

                #for(move in board.)

        elif(state == "choose_move"):
            worker = self.board.playgame.selected_worker
            move = worker.get_move(self)

            if not (move is None) and self.board.check_move(move):
                valid_squares = self.board.get_worker_moves(self.board.playgame.selected_worker)
                for square in valid_squares:
                    square.button.config(bg = "white")

                self.board.playgame.game_state = "choose_build"
                self.board.playgame.execute_move(move)

                valid_builds = self.board.get_worker_builds(self.board.playgame.selected_worker)
                #print(len(valid_builds))
                for square in valid_builds:
                    print("boop")
                    square.button.config(bg = "green")
                
                

            
        elif(state == "choose_build"):
            worker = self.board.playgame.selected_worker
            build = worker.get_build(self)
            
            if not (build is None) and self.board.check_build(build):
                valid_builds = self.board.get_worker_builds(self.board.playgame.selected_worker)
                #print(len(valid_builds))
                for square in valid_builds:
                    print("boop")
                    square.button.config(bg = "white")

                self.board.playgame.game_state = "choose_worker"
                self.board.playgame.execute_build(build)
            




class Action:
    def __init__(self, direction, worker):
        self.direction = direction
        self.worker = worker

    def get_new_coords(self):
        curr_row = self.worker.row
        curr_col = self.worker.col
        new_row = curr_row + directions.get(self.direction)[0]
        new_col = curr_col + directions.get(self.direction)[1]
        return [new_row, new_col]

    def __eq__(self, other):
        return self.direction == other.direction and self.worker.name == other.worker.name

class Move(Action):
    def __init__(self, direction, worker):
        super().__init__(direction, worker)


class Build(Action):
    def __init__(self, direction, worker):
        super().__init__(direction, worker)